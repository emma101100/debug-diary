# 第二次积分赛的视觉笔记
## 4月7日完成了基本的功能
### 角点检测的来源与方法
- **轮廓检测的基本原理**
  - 代码使用 `cv2.findContours(binary, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)` 从二值化图像中提取轮廓。
  - 二值化图像（`binary`）是预处理后的黑白图像，白色区域表示目标物体，黑色为背景。
  - `cv2.RETR_TREE` 表示检测所有轮廓并建立层级关系，`cv2.CHAIN_APPROX_SIMPLE` 简化轮廓点，仅保留关键点（如拐角）。
  - 返回的 `contours` 是一个轮廓列表，每个轮廓是一组连续点的集合。

- **多边形近似生成角点**
  - 对于每个轮廓：
    - `cv2.contourArea(contour)` 计算面积，小于 100 的轮廓被过滤掉（避免噪声）。
    - `cv2.arcLength(contour, True)` 计算轮廓周长，`epsilon = 0.02 * 周长` 作为近似精度参数。
    - `cv2.approxPolyDP(contour, epsilon, True)` 将轮廓近似为多边形，返回顶点坐标（即角点）。
  - 每个顶点是一个二维坐标 `(x, y)`，被添加到 `corners` 列表中。
  - 这意味着“角点”实际上是目标物体轮廓的多边形顶点，通常对应于形状的拐角或显著特征点。

- **角点的可视化**
  - `cv2.circle(original_frame, (x, y), 5, (0, 255, 0), -1)` 在图像上绘制绿色实心圆标记每个角点，便于观察。

### `corners` 和 `filtered_corners` 的作用
- **初始角点的提取**
  - `corners` 列表最初包含所有检测到的多边形顶点，可能包括重复或过密的点（例如由于噪声或轮廓细节过多）。

- **过滤过近角点的算法**
  - 代码通过距离过滤优化角点：
    - 定义最小距离 `min_distance = 10`。
    - 对于每个角点 `corner`，将其转为 NumPy 数组 `current_point`。
    - 检查 `current_point` 与已保留的 `filtered_corners` 中每个点的距离（`np.linalg.norm` 计算欧几里得距离）。
    - 如果距离小于 10，则丢弃该角点（`should_keep = False`）；否则加入 `filtered_corners`。
  - 最终，`corners = filtered_corners`，只保留彼此距离足够的独立角点。
  - **目的**：减少冗余，提高后续处理的准确性。

### 当前角点（`curr_corner`）与上一帧角点（`prev_corner`）的关系
- **角点的帧间跟踪**
  - `prev_corners` 是上一帧的角点列表，初始为空，每帧结束后更新为当前帧的 `corners`（`prev_corners = corners.copy()`）。
  - `corners` 是当前帧检测到的角点。
  - 代码通过比较当前帧和上一帧的角点，判断角点的运动轨迹。

- **寻找最近角点的逻辑**
  - 对于每个当前角点 `curr_corner`（取其 x 坐标 `x_curr`）：
    - 遍历上一帧的每个角点 `prev_corner`（取其 x 坐标 `x_prev`）。
    - 计算两者 x 坐标的绝对差值 `dist = abs(x_curr - x_prev)`。
    - 记录距离最小的 `prev_corner` 作为 `closest_prev`，即当前角点在上一帧中最可能的匹配点。
  - **假设**：距离最近的角点被认为是同一个物体在两帧间的移动结果（基于帧间变化较小的前提）。

- **角点经过中心的判断条件**
  - 如果找到匹配的 `closest_prev`：
    - 检查上一帧角点的 x 坐标 `x_prev` 是否在中心线左侧（`x_prev < center_x`）。
    - 检查当前帧角点的 x 坐标 `x_curr` 是否在中心线右侧或中心（`x_curr >= center_x`）。
    - 如果满足条件，说明角点从左向右经过了图像中心，`corner_pass_count` 增加 1。
  - `break` 确保每帧只计数一次，避免重复。
  - **意义**：检测物体（如车库标志）从画面左侧移动到右侧的次数。

### 算法的整体逻辑与目的
- **角点运动的意义**
  - 角点通常对应于场景中的显著特征（如车库的边缘或标记）。
  - 跟踪角点从左到右经过中心，反映了车辆相对于这些特征的移动。
  - `corner_pass_count` 记录经过的特征数量，用于判断车辆位置。

- **模式切换的依据**
  - 根据 `corner_pass_count`：
    - 0-2 次：保持 "Approaching"（接近模式），可能是经过前两个车库。
    - 3 次：切换到 "Backing"（倒车模式），可能是到达目标车库。
  - **目的**：实现基于视觉的场景识别，自动切换导航模式（如从前进到倒车入库）。

### 不足
- error由参考线的y和检测到直线中点的y作差得到，虽然能实现功能，但是对于纠正角度是不是还有些滞后？是否可以多取几个位置的点来直接表示此时直线的方向，而不是通过多个时刻中心位置的点来反映方向？
# ä¸²å£ä¸­æ–­æ•°æ®ä¸¢å¤±

## ä¸²å£ä¸­æ–­ + ç¯å½¢ç¼“å†²åŒºï¼ˆå›ºå®š å­—èŠ‚æ•°æ®æ”¶å‘ï¼‰

**é€‚ç”¨äºï¼š**  
- ä¸²å£é€šä¿¡ **æ¯å¸§å›ºå®šå­—èŠ‚**

- **ä¸ä¼šä¸¢æ•°æ®ï¼ŒFIFO å…ˆè¿›å…ˆå‡º**

- **æ”¶åˆ°å®Œæ•´å­—èŠ‚æ‰è§£æï¼Œé¿å… `switch-case` è¯¯è§¦å‘**

- ä»¥æ¯å¸§å›ºå®š4å­—èŠ‚ä¸ºä¾‹

  ---

###  å¤´æ–‡ä»¶ `ring_buffer.h`

```c
#ifndef __RING_BUFFER_H
#define __RING_BUFFER_H

#include "stm32f1xx_hal.h"

#define RINGBUFF_LEN 64  // ç¯å½¢ç¼“å†²åŒºå¤§å°ï¼Œå¿…é¡»æ˜¯ 4 çš„å€æ•°ï¼ˆä¿è¯å®Œæ•´å¸§å­˜å‚¨ï¼‰
#define FRAME_SIZE 4  // æ¯å¸§å›ºå®š 4 å­—èŠ‚

typedef struct
{
    uint8_t buffer[RINGBUFF_LEN];  // å­˜å‚¨æ¥æ”¶åˆ°çš„æ•°æ®
    volatile uint16_t head;  // å¤´æŒ‡é’ˆ
    volatile uint16_t tail;  // å°¾æŒ‡é’ˆ
    volatile uint16_t length;  // å½“å‰ç¼“å†²åŒºæ•°æ®é•¿åº¦
} RingBuffer_t;

// å‡½æ•°å£°æ˜
void RingBuffer_Init(RingBuffer_t *ringBuff);
uint8_t Write_RingBuffer(RingBuffer_t *ringBuff, uint8_t data);
uint8_t Read_RingBuffer(RingBuffer_t *ringBuff, uint8_t *rData);
uint8_t Read_Frame(RingBuffer_t *ringBuff, uint8_t *frame);

#endif
```

###  ç¯å½¢ç¼“å†²åŒºå®ç° `ring_buffer.c`

```c
#include "ring_buffer.h"

// åˆå§‹åŒ–ç¯å½¢ç¼“å†²åŒº
void RingBuffer_Init(RingBuffer_t *ringBuff)
{
    ringBuff->head = 0;
    ringBuff->tail = 0;
    ringBuff->length = 0;
}

// å‘ç¯å½¢ç¼“å†²åŒºå†™å…¥æ•°æ®
uint8_t Write_RingBuffer(RingBuffer_t *ringBuff, uint8_t data)
{
    if (ringBuff->length >= RINGBUFF_LEN)  // åˆ¤æ–­ç¼“å†²åŒºæ˜¯å¦å·²æ»¡
    {
        return 0;  // ç¼“å†²åŒºå·²æ»¡ï¼Œå†™å…¥å¤±è´¥
    }

    ringBuff->buffer[ringBuff->head] = data;  // å­˜å‚¨æ•°æ®
    ringBuff->head = (ringBuff->head + 1) % RINGBUFF_LEN;  // é˜²æ­¢è¶Šç•Œ
    ringBuff->length++;

    return 1;  // å†™å…¥æˆåŠŸ
}

// ä»ç¯å½¢ç¼“å†²åŒºè¯»å– 4 å­—èŠ‚æ•°æ®å¸§
uint8_t Read_Frame(RingBuffer_t *ringBuff, uint8_t *frame)
{
    if (ringBuff->length < FRAME_SIZE)
    {
        return 0;  // ä¸è¶³ 4 å­—èŠ‚ï¼Œè¯»å–å¤±è´¥
    }

    for (uint8_t i = 0; i < FRAME_SIZE; i++)  // è¯»å– 4 å­—èŠ‚
    {
        frame[i] = ringBuff->buffer[ringBuff->tail];
        ringBuff->tail = (ringBuff->tail + 1) % RINGBUFF_LEN;  // ç¯å½¢é€’å¢
        ringBuff->length--;
    }

    return 1;  // è¯»å–æˆåŠŸ
}
```

### ä¸²å£ä¸­æ–­ + ç¯å½¢ç¼“å†²åŒº `main.c`
```c
#include "main.h"
#include "ring_buffer.h"
#include "usart.h"

uint8_t uart_rx_data;  // ä¸²å£æ¥æ”¶
RingBuffer_t uart_rx_ring;  // ç¯å½¢ç¼“å†²åŒºå®ä¾‹

// åˆå§‹åŒ– UART å¹¶å¼€å¯ä¸­æ–­
void UART_Init()
{
    HAL_UART_Receive_IT(&huart1, &uart_rx_data, 1);
}

// ä¸²å£æ¥æ”¶ä¸­æ–­å›è°ƒ
void USART1_IRQHandler(void)
{
    if (__HAL_UART_GET_FLAG(&huart1, UART_FLAG_RXNE)) // ä¸²å£æ”¶åˆ°æ•°æ®
    {
        uint8_t data = (uint8_t)(huart1.Instance->DR & 0xFF);  // è¯»å–æ•°æ®
        Write_RingBuffer(&uart_rx_ring, data);  // å­˜å…¥ç¯å½¢ç¼“å†²åŒº
		HAL_UART_Receive_IT(&huart1, &uart_rx_data, 1);
    }
}

// å¤„ç† UART æ¥æ”¶åˆ°çš„æ•°æ®
void Process_UART_Data()
{
    uint8_t frame[FRAME_SIZE];  // å­˜å‚¨ 4 å­—èŠ‚æ•°æ®

    while (Read_Frame(&uart_rx_ring, frame))  // è¯»å–å®Œæ•´ 4 å­—èŠ‚å¸§
    {
        switch (frame[0])  // è§£æç¬¬ 1 å­—èŠ‚ä½œä¸ºæŒ‡ä»¤
        {
            case 0xA1:
                printf("æ”¶åˆ° A1 æŒ‡ä»¤ï¼Œæ•°æ®ï¼š%d %d %d\n", frame[1], frame[2], frame[3]);
                break;
            case 0xB2:
                printf("æ”¶åˆ° B2 æŒ‡ä»¤ï¼Œæ•°æ®ï¼š%d %d %d\n", frame[1], frame[2], frame[3]);
                break;
            default:
                printf("æœªçŸ¥æŒ‡ä»¤ï¼š%d %d %d %d\n", frame[0], frame[1], frame[2], frame[3]);
                break;
        }
    }
}

// ä¸»å‡½æ•°
int main(void)
{
    HAL_Init();
    SystemClock_Config();
    MX_GPIO_Init();
    MX_USART1_UART_Init();
    RingBuffer_Init(&uart_rx_ring);
    UART_Init();

    while (1)
    {
        Process_UART_Data();  // å¤„ç†æ¥æ”¶åˆ°çš„æ•°æ®
        HAL_Delay(10);
    }
}

```

![uart_ring_buffer_detailed_flowchart_english](./uart_ring_buffer_detailed_flowchart_english.png)



---

## ä½¿ç”¨ä¸²å£ç©ºé—²ä¸­æ–­æ¥æ”¶ä¸å®šé•¿æ•°æ®

### æ–¹æ¡ˆè¯´æ˜

ä½¿ç”¨ DMAï¼Œåœ¨ä¸²å£æ¥æ”¶ç»“æŸä¹‹åä¼šäº§ç”Ÿç©ºé—²ä¸­æ–­ï¼Œåœ¨ç©ºé—²ä¸­æ–­é‡Œé¢å†æŠŠ DMA çš„æ•°æ®æ¬è¿åˆ°å†…å­˜ã€‚

**ç‰¹ç‚¹ï¼š**

- **é€‚ç”¨äºä¸å®šé•¿æ•°æ®çš„ä¸²å£é€šä¿¡**
- **é¿å…æ•°æ®ä¸¢å¤±ï¼Œæé«˜æ¥æ”¶æ•ˆç‡**
- **åŸºäº DMA å’Œä¸²å£ç©ºé—²ä¸­æ–­ (IDLE IRQ)**

---

###  ä»£ç å®Œæ•´ç¤ºä¾‹

#### å®šä¹‰å˜é‡

```c
#include <stdio.h>
uint8_t usart1_rx_buf[1024]={'\0'}; // 1024 æ˜¯ç¼“å†²åŒºçš„é•¿åº¦
```

#### å¼€å¯ DMA æ¥æ”¶ç©ºé—²ä¸­æ–­

```c
HAL_UARTEx_ReceiveToIdle_DMA(&huart1, usart1_rx_buf, sizeof(usart1_rx_buf));
```

#### æ·»åŠ å›è°ƒå‡½æ•°

```c
void HAL_UARTEx_RxEventCallback(UART_HandleTypeDef *huart, uint16_t Size)
{
    if(huart == &huart1)
    {
        printf("%s", usart1_rx_buf);
        
        // å¦ä¸€ç§æ–¹å¼ï¼š
        // usart1_data_len = bufflen - huart->hdmarx->Instance->NDTR; // è·å–å¸§é•¿
        // HAL_UART_Transmit(&huart1, usart1_rx_buf, usart1_data_len, 100);

        // ä½¿ DMA ä»å¤´å­˜æ•°æ®
        huart->hdmarx->Instance->NDTR = 1024;
        
        // é‡æ–°æ‰“å¼€ DMA æ¥æ”¶ï¼Œç©ºé—²ä¸­æ–­
        HAL_UARTEx_ReceiveToIdle_DMA(&huart1, usart1_rx_buf, 1024);
    }
}
```

![uart_dma_idle_flowchart](./uart_dma_idle_flowchart.png)

---

## FreeRTOS `EventFlags` æ–¹æ¡ˆ

### æ–¹æ¡ˆè¯´æ˜

1. **UART è§¦å‘ `RXNE`ï¼ˆæ¥æ”¶éç©ºï¼‰ä¸­æ–­**

2. **æ•°æ®å­˜å…¥ `usart1_rx_buf[]`ï¼‰**

3. **è§¦å‘ `UART_RX_EVENT` äº‹ä»¶**

4. **UART ä»»åŠ¡ `uart_task()` è¢«å”¤é†’ï¼Œè¯»å– `usart1_rx_buf[]` å¹¶è§£æ**

5. **å¾ªç¯é‡å¤ï¼ŒæŒç»­æ¥æ”¶æ•°æ®**

6. ä»¥æ¯å¸§å›ºå®š4å­—èŠ‚ä¸ºä¾‹

   ---

### ä»£ç å®Œæ•´ç¤ºä¾‹

#### å¤´æ–‡ä»¶ `uart_task.h`

```c
#ifndef __UART_TASK_H
#define __UART_TASK_H

#include "FreeRTOS.h"
#include "task.h"
#include "event_groups.h"
#include "stm32f1xx_hal.h"

#define UART_RX_EVENT (1 << 0)  // äº‹ä»¶æ ‡å¿—ä½
#define FRAME_SIZE 4  // æ¯å¸§å›ºå®š 4 å­—èŠ‚

extern EventGroupHandle_t uart_event_group;
extern uint8_t usart1_rx_buf[FRAME_SIZE];
extern volatile uint16_t usart1_data_len;

void UART_Task(void *argument);
void UART_Init(void);
void USART1_IRQHandler(void);

#endif
```

------

#### **ğŸ“Œ `uart_task.c`**

```c
#include "uart_task.h"
#include "usart.h"

EventGroupHandle_t uart_event_group;  // äº‹ä»¶ç»„
uint8_t usart1_rx_buf[FRAME_SIZE];  // ä¸²å£æ¥æ”¶ç¼“å†²åŒº
volatile uint16_t usart1_data_len = 0;  // å½“å‰æ¥æ”¶åˆ°çš„æ•°æ®é•¿åº¦

// ä¸²å£ä¸­æ–­æ¥æ”¶æ•°æ®
void USART1_IRQHandler(void)
{
    if (__HAL_UART_GET_FLAG(&huart1, UART_FLAG_RXNE))  // ä¸²å£æ”¶åˆ°æ•°æ®
    {
        uint8_t data = (uint8_t)(huart1.Instance->DR & 0xFF);  // è¯»å–æ•°æ®

        if (usart1_data_len < FRAME_SIZE)  // ç¡®ä¿ç¼“å†²åŒºä¸æº¢å‡º
        {
            usart1_rx_buf[usart1_data_len++] = data;
        }

        // å½“æ”¶åˆ° 4 å­—èŠ‚æ—¶ï¼Œè§¦å‘äº‹ä»¶
        if (usart1_data_len == FRAME_SIZE)  
        {
            xEventGroupSetBits(uart_event_group, UART_RX_EVENT);
        }
    }
}

// UART ä»»åŠ¡       
void UART_Task(void *argument)
{
    while (1)
    {
        // ç­‰å¾…ä¸²å£äº‹ä»¶ï¼Œä»»åŠ¡è¿›å…¥é˜»å¡æ¨¡å¼
        xEventGroupWaitBits(uart_event_group, UART_RX_EVENT, pdTRUE, pdFALSE, portMAX_DELAY);

        // å¤„ç†æ¥æ”¶åˆ°çš„æ•°æ®
        printf("Received: %d %d %d %d\n", usart1_rx_buf[0], usart1_rx_buf[1], usart1_rx_buf[2], usart1_rx_buf[3]);

        // æ¸…ç©ºç¼“å†²åŒº
        usart1_data_len = 0;
    }
}

// UART åˆå§‹åŒ–
void UART_Init(void)
{
    uart_event_group = xEventGroupCreate();  // åˆ›å»ºäº‹ä»¶æ ‡å¿—ç»„

    HAL_UART_Receive_IT(&huart1, (uint8_t *)NULL, 1);  // å¯åŠ¨ä¸²å£ä¸­æ–­
}
```

------

#### **ğŸ“Œ `main.c`**

```c
#include "main.h"
#include "cmsis_os.h"
#include "uart_task.h"

// ä¸»å‡½æ•°
int main(void)
{
    HAL_Init();
    SystemClock_Config();
    MX_GPIO_Init();
    MX_USART1_UART_Init();

    UART_Init();
    
    // åˆ›å»º UART ä»»åŠ¡
    osThreadDef(UART_Task, UART_Task, osPriorityNormal, 0, 128);
    osThreadCreate(osThread(UART_Task), NULL);

    // å¯åŠ¨è°ƒåº¦å™¨
    osKernelStart();

    while (1);
}
```

![FreeRTOS_UART_EventFlags_Flowchart](./FreeRTOS_UART_EventFlags_Flowchart.png)
